/* eslint-disable no-undef */
/* eslint-disable no-unused-vars */
/* eslint-disable prefer-const */
/* eslint-disable no-constant-condition */
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable lines-around-comment */
/* eslint-disable react/prop-types */
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
//@ts-nocheck

import React, { useEffect, useRef, useState } from 'react';
import { createClient, LiveTranscriptionEvents } from '@deepgram/sdk';
import {
  Avatar,
  Select,
  Modal,
  Button,
  Radio,
  Popover,
  message,
  Tag,
  Table,
  Input,
} from 'antd';
import PDF from '../assets/icons/pdf.png';
import {
  IoDocumentTextOutline,
  IoSend,
  IoDocumentTextSharp,
  IoEyeOutline,
  IoCloudUploadOutline,
} from 'react-icons/io5';
import Markdown from 'react-markdown';
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { oneDark } from 'react-syntax-highlighter/dist/esm/styles/prism';
import remarkGfm from "remark-gfm";
import rehypeRaw from "rehype-raw";
import { IoMdCloudUpload } from 'react-icons/io';
import moment from 'moment';
import {
  DislikeFilled,
  DislikeOutlined,
  EyeInvisibleOutlined,
  EyeOutlined,
  LikeFilled,
  LikeOutlined,
  MutedOutlined,
  PauseCircleOutlined,
  RedoOutlined,
  SearchOutlined,
  SoundFilled,
  SoundOutlined,
} from '@ant-design/icons';

import OrganisationStore from '../store/organisationsStore/OrganisationsStore';
import {
  RobotOutlined,
  PaperClipOutlined,
  CopyOutlined,
  PlusOutlined,
  AudioOutlined,
  CloseOutlined,
  SendOutlined,
  DeleteOutlined,
  MessageOutlined,
} from '@ant-design/icons';
import { BsEmojiSmile } from 'react-icons/bs';
import EmojiPicker from 'emoji-picker-react';
import { FaMicrophone, FaRegPlayCircle } from 'react-icons/fa';
import { LiveAudioVisualizer } from 'react-audio-visualize';
import UseAuthStore from '../store/auth/UseAuthStore';
import logo from '../assets/Vector.svg';
import TextArea from 'antd/es/input/TextArea';
import chatBg from '../assets/chat_bg_real.jpg';
import chatBgNight from '../assets/chat-bg-real-night.jpg';
import giphy from '../assets/image/giphy (2).gif';
import useDashboardStore from '../store/dashboard/DashBoardStore';
import SourceModal from './SourceModal';
import SourceDocuments from './SourceDocuments';
import FileComfirmPopup from './UploadConfirmation';
import DocumentIcon from '../utils/documentIcon';
import CryptoJS from 'crypto-js';

import pdf from '../assets/icons/Pdf.svg';
import docx from '../assets/icons/DocX.svg';
import xls from '../assets/icons/XLS.svg';
import xlsx from '../assets/icons/XLSX (1).svg';
import doc from '../assets/icons/Doc.svg';
import text from '../assets/icons/txt.svg';
import csv from '../assets/icons/CSV.svg';
import PreviewImage from './Preview';
import GroupList from './GroupList';
import { useLocation, useNavigate } from 'react-router-dom';
import ProgressLoader from './ProgressLoader';
import Loading from './Loading';
import { MdDelete } from 'react-icons/md';
import LibraryDocument from './LibraryDocument';
import { includes } from 'lodash';
import CustomModalButton from './common/Button';
import { handleCreateNote } from '../utils/helpers/noteHelpers';
import SearchBar from './common/SearchBar';
import stickyNote from "../assets/textFile.png"
import parse from 'html-react-parser';
import { hexToLightRgba } from '../utils/helper';


const apiUrl =
  (import.meta.env.VITE_REACT_APP_API_URL as string) || window.location.origin;

const currentHour = new Date().getHours();
const backgroundImage = currentHour >= 7 && currentHour < 18 ? chatBg : chatBg;

const AskDocument = React.memo(({
  documents,
  sessionId,
  setSessionId,
  listData,
  subscriptionHistory,
  chatCleared,
  setChatCleared,
  clearChatHistory,
  showComfirmationPopup,
  setShowConfirmationPopup,
  sessionList,
  createSession,
  navigate,
  fetchSessionList,
  isNote,
  setIsNote,
  noteHandledRef
}) => {
  const user = localStorage.getItem('User');
  const socketRef = useRef(null);
  const options = [
    'Offensive/Unsafe',
    'Irrelevant',
    'Failed to answer',
    'Partially incorrect',
    'Other',
  ];
  const { authData } = UseAuthStore();
  const emojiPickerRef = useRef(null);

  const imageSrc = OrganisationStore((state) => state.imageSrc);
  const selectedTapestry = OrganisationStore((state) => state.selectedTapestry);
const getUserFeedback = OrganisationStore((state) => state.getUserFeedback);
const handlePreviewLibrary = OrganisationStore((state) => state.handlePreviewLibrary);
const role = OrganisationStore((state) => state.role);
const getAllSource = OrganisationStore((state) => state.getAllSource);
const handlePipView = OrganisationStore((state) => state.handlePipView);
const createNote = OrganisationStore((state) => state.createNote);


  const [isModalOpen, setIsModalOpen] = useState(false);
  const [allSources, setAllSources] = useState([]);
  const [isUploading, setIsUploading] = useState(false);
  const [previewItems,setPreviewItems] = useState([])
  const deepgram = createClient('c09c2396df3c5dc716a258d13f85fa4c4685120b');
  const [fileAllDetails, setFileAllDetails] = useState({
    author: selectedTapestry?.tapestry_user_name,
    title: '',
    relevantDate: '',
    expiryDate: '',
    summary: '',
  });

  const [generateDocxBlob, setGenerateDocxBlob] = useState({});

  const [captureImg, setCaptureImg] = useState(null);
  const transcriptChunksRef = useRef([]);
  const [finalTranscript, setFinalTranscript] = useState('');
  const finalTranscriptRef = useRef(finalTranscript);
  const [feedback, setFeedback] = useState([]);
  const [generatingId, setGeneratingId] = useState('');
  const [selected, setSelected] = useState([]);
  const [selectedDoc, setSelectedDoc] = useState([]);
  const [selectedShown, setSelectedShown] = useState([]);
  const messagesEndRef = useRef(null);
  const mediaRecorderRef = useRef(null);
  const audioStreamRef = useRef(null);
  const [isPlaying, setIsplaying] = useState(false);
  const audioRef = useRef(null);
  const [feedbackModal, setfeedbackModal] = useState({
    open: false,
    id: null,
  });
  const [progress, setProgress] = useState('5');
  const [progressBar, setProgressBar] = useState(false);
  const [temporaryFeedback, setTemporaryFeedback] = useState({});
  const recognitionRef = useRef(null);
  const [response, setResponse] = useState('');
  const [yesUploadLoading, setYesUploadLoading] = useState(false);
  const [noUploadLoading, setNoUploadLoading] = useState(false);

  const [recentUpload, setRecentUpload] = useState([]);
  const [audioUrl, setAudioUrl] = useState(null);
  const [voiceUrl, setVoiceUrl] = useState('');
  const [voiceNoteCaption,setVoiceNoteCaption] = useState('')
  const [newMessage, setNewMessage] = useState('');
  const [voiceText, setVoiceText] = useState('');
  const [showEmojiPicker, setShowEmojiPicker] = useState(false);
  const [isPopoverVisible, setIsPopoverVisible] = useState(false);
  const [isInnerOpen, setIsInnerOpen] = useState(false);
  const [availableDocuments, setAvailableDocuments] = useState([]);
  const AddGroupDocumentApi = useDashboardStore(
    (state) => state.AddGroupDocumentApi
  );

  const AddDocumentApi = useDashboardStore((state) => state.AddDocunentsApi);
  const [audioToShow, setAudioToShow] = useState({
    url: '',
    generatedUrl: '',
  });
  const [imageToShow, setImageToShow] = useState({
    url: '',
    generatedUrl: '',
  });

  const uploadDocumentsApi = useDashboardStore(
    (state) => state.uploadDocumentsApi
  );
  const [audio, setAudio] = useState('');

  const [accumulatedContent, setAccumulatedContent] = useState('');
  const [fileUploadPopup, setFileUploadPopup] = useState(false);
  const [selectedFile, setSelectedFile] = useState(null);
  const [selectedTab, setSelectedTab] = useState('chat');
  const [selectedThumbnailFile, setSelectedThumbnailFile] = useState(null);
  const [messages, setMessages] = useState('');
  const [isRecording, setIsRecording] = useState(false);
  const [conversation, setConversation] = useState([]);
  const [conversations, setConversations] = useState();
  const callMadeRef = useRef(false); // Ref to track API call
  const [groupName, setGroupName] = useState('');

  const [groupValue, setGroupValue] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [caption, setCaption] = useState('');
  const [audioBlob, setAudioBlob] = useState(null);
  const [audioURL, setAudioURL] = useState('');
  const [isDeleteIconClicked, setIsDeleteIconClicked] = useState(false);
  const [previewThumbnailImage, setPreviewThumbnailImage] = useState(null);
  const storedUserData = localStorage.getItem('User');
  const userData = JSON.parse(storedUserData);
  const location = useLocation();
  const queryParams = new URLSearchParams(location.search);
  
  
  const [searchText,setSearchText] = useState("")
  const [openAddSourceTable, setOpenAddSourceTable] = useState(false);
  const [selectedFileName, setSelectedFileName] = useState([]);
  const [selectedFileId, setSelectedFileId] = useState([]);

  const generateSignedUrlApi = useDashboardStore(
    (state) => state.generateSignedUrlApi
  );
  const getChatHistoryApi = useDashboardStore((state) => state.chatHistoryAPI);

  const handleAllSource = async () => {
    try {
      const response = await getAllSource({
        tapestry_id:selectedTapestry?.id,
        search: searchText
      });
      if (response.status == 200) {
        const list = response.data.body || [];
        setAllSources(list);
      }
    } catch (err) {
      console.log(err);
    }
  };

  const getChatHistory = async () => {
    try {
      const response = await getChatHistoryApi({
        tapestry_id:selectedTapestry?.id,
        session_id: sessionId,
      });

      if (response.status == 200) {
        if (response.data.body.length > 0) {
          const feedbackList = {};
          for (let item of response.data.body) {
            if (item.good_response) {
              feedbackList[item.id] = 'like';
            } else if (item.bad_response) {
              feedbackList[item.id] = 'dislike';
            }
          }
          setTemporaryFeedback(feedbackList);
        }
        const temp = sessionList?.filter((ele) => ele.id === sessionId)
        if (response.data.body?.length === 1 && temp[0]?.name === '') {
          fetchSessionList(true)
        }
        setConversation(response.data.body);
      }
    } catch (err) {
      console.log(err);
    }
  };

  useEffect(() => {
    if ( selectedTapestry?.id && sessionId) {
      getChatHistory();
    }
  }, [isLoading, sessionId]);

  useEffect(() => {
    if (chatCleared) {
      setConversation([]);
      setChatCleared(false);
    }
  }, [chatCleared]);

  useEffect(() => {
    handleSpeachToText();
  }, [isRecording]);

  const handlePreview = (previewId) => {
    setPreviewItems((prev) => {
      if (prev.includes(previewId)) {
        return prev.filter((item) => item !== previewId);
      } else {
        return [...prev, previewId];
      }
    });
  };

  const handleSpeachToText = () => {
    try {
      if (isRecording) {
        handleCallChildFunction();
      } else {
        stopRecording();
      }
    } catch (error) {
      console.log('Error while recording ', error);
    }
  };

  const handleCallChildFunction = async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      audioStreamRef.current = stream;
      startRecording(stream);
    } catch (err) {
      setIsRecording(false)
      alert(
        'Microphone not accessible. Please check your device settings and permissions.'
      );
    }
  };

  const startRecording = (stream) => {
    try {
      setNewMessage('');
      const mediaRecorder = new MediaRecorder(stream);
      mediaRecorderRef.current = mediaRecorder;

      // Store WebSocket in useRef so it can be accessed globally
      socketRef.current = new WebSocket('wss://api.deepgram.com/v1/listen', [
        'token',
        '0270aa9f248b52333c16581aa13ea251a09d15e5',
      ]);

      socketRef.current.onopen = () => {
        console.log('✅ Connected to Deepgram WebSocket');
        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0 && socketRef.current?.readyState === 1) {
            socketRef.current.send(event.data);
          }
        };
        mediaRecorder.start(200);
      };

      socketRef.current.onmessage = (message) => {
        try {
          const data = JSON.parse(message.data);
          if (data.channel?.alternatives?.[0]?.transcript) {
            setNewMessage(
              (prev) => prev + ' ' + data.channel.alternatives[0].transcript
            );
          }
        } catch (error) {
          console.error('Error parsing Deepgram message:', error);
        }
      };

      socketRef.current.onerror = (error) =>
        console.error('Deepgram WebSocket error:', error);
      socketRef.current.onclose = () =>
        console.log('Deepgram WebSocket closed');
    } catch (error) {
      console.error('Error accessing microphone:', error);
      alert('Microphone not accessible. Please check your device settings.');
    }
  };

  const stopRecording = () => {
    if (mediaRecorderRef.current) {
      mediaRecorderRef.current.stop();
      mediaRecorderRef.current = null;
    }

    if (audioStreamRef.current) {
      audioStreamRef.current.getTracks().forEach((track) => track.stop());
      audioStreamRef.current.getAudioTracks().forEach((track) => track.stop());
      audioStreamRef.current = null;
    }

    // Close Deepgram WebSocket connection properly
    if (socketRef.current) {
      console.log('Closing Deepgram WebSocket...');
      socketRef.current.close();
      socketRef.current = null; // Ensure it's cleared
    }
    setIsRecording(false);
    sendMessage();
  };

  const findIcon = (extension, url, thumbnail) => {
    if (
      extension == 'png' ||
      extension == 'jpg' ||
      extension == 'jpeg' ||
      extension == 'webp' ||
      extension == 'svg'
    ) {
      return (
        <img src={url} className='rounded-lg object-contain m-auto h-auto' />
      );
    }
    if (
      extension == 'mov' ||
      extension == 'mp4' ||
      extension == 'webm' ||
      extension == 'mkv'
    ) {
      return (
        <video
          controls
          src={url}
          poster={thumbnail}
          style={{ height: '200px' }}
          className='rounded-lg '
        ></video>
      );
    } else if (extension == 'mp3' || extension == 'opus') {
      return (
        <div className='max-w-40'>
          <img
            src={
              thumbnail ||
              'https://local-testing-tapestry-bucket.s3.eu-north-1.amazonaws.com/audiofile_thumbnail.png'
            }
            className='rounded-lg object-contain m-auto h-auto'
          />
          <audio controls key={url} className='shadow-md rounded-full max-w-40'>
            <source src={url} />
            Your browser does not support the audio element.
          </audio>
        </div>
      );
    } else if (
      extension == 'docx' ||
      extension == 'xlsx' ||
      extension == 'txt'
    ) {
      return (
        <img
          src={thumbnail}
          className='rounded-lg object-contain m-auto h-auto'
        />
      );
    } else {
      return (
        <LibraryDocument
          thumbnail={thumbnail}
          file_id={url}
          file_type={extension}
        />
      );
    }
  };

  const handleSubmitResponse = async (type, response, msgId) => {
    try {
      const payload = {
        response,
        type,
        msg_id: msgId,
      };

      const apiResponse = await getUserFeedback(payload);

      if (apiResponse?.status === 200) {
        if (msgId in temporaryFeedback) {
          const temp = temporaryFeedback;
          if (response) {
            setTemporaryFeedback({ ...temporaryFeedback, [msgId]: type });
          } else {
            delete temp[msgId];
            setTemporaryFeedback(temp);
          }
        } else {
          setTemporaryFeedback({ ...temporaryFeedback, [msgId]: type });
        }
      } else {
        message.error('Failed to submit response');
      }
    } catch (err) {
      message.error('Failed to submit response');
    } finally {
      setfeedbackModal({
        open: false,
        id: null,
      });
      setResponse(''), setFeedback([]);
    }
  };

  const handleNavigation = (selected) => {
    const secretKey = 'mySecretKey';
    const idString = selected?.id.toString();
    const encryptedId = CryptoJS.AES.encrypt(idString, secretKey).toString();
    navigate(`/library/preview/${encodeURIComponent(encryptedId)}`);
  };

  const handleGeneateSignedUrl = async (urlPassed, isAudio) => {
    try {
      const urlRegex = /https:\/\/[^\s"]+/;
      const match = urlPassed.match(urlRegex);
      const url = match?.[0] || urlPassed;
      const audio = audioRef.current;
      if (isAudio == 'audio' && audioToShow?.url == urlPassed) {
        if (!audio) return;
        audio.play();
        setIsplaying(true);
      }

      const response = await generateSignedUrlApi({ url });
      if (response?.success === true && response?.body?.signedUrl) {
        if (isAudio == 'audio') {
          setAudioToShow({
            url: urlPassed,
            generatedUrl: response?.body?.signedUrl,
          });
          setIsplaying(true);
        } else if (isAudio == 'image') {
          setImageToShow({
            url: urlPassed,
            generatedUrl: response?.body?.signedUrl,
          });
        } else {
          window.open(response?.body?.signedUrl, '_blank');
        }
      } else {
        message.error('Failed to load Documents');
      }
    } catch (err) {
      console.log(err, 'ess======>');
      message.error('Failed to load Documents');
    }
  };
 
  useEffect(() => {
    if (queryParams.get('group')) {
      const group = {
        label: queryParams.get('group'),
        value: queryParams.get('group'),
      };
      handleGroupSelect(group);

      // Remove 'group' from the URL
      const newParams = new URLSearchParams(window.location.search);
      // newParams.delete('group');
      // window.history.replaceState(null, '', `${window.location.pathname}${newParams}`);
    } else if (queryParams.get('document')) {
      setRecentUpload([{ name: queryParams.get('document') }]);

      // Remove 'group' from the URL
      const newParams = new URLSearchParams(window.location.search);
      // newParams.delete('document');
      // window.history.replaceState(null, '', `${window.location.pathname}${newParams}`);
    }
    else if (!noteHandledRef.current && isNote) {
      console.log(isNote);
      
      handlePipView([isNote], true);
      setRecentUpload([{ name: isNote?.title, type: 'note' }]);
      const newParams = new URLSearchParams(window.location.search);
      window.history.replaceState(null, '', `${window.location.pathname}${newParams}`);
      setIsNote(null);
      noteHandledRef.current = true;
    }
    else if (queryParams.get('folder')) {
      setRecentUpload([{ name: queryParams.get('folder'), type: 'folder' }]);

      // Remove 'group' from the URL
      const newParams = new URLSearchParams(window.location.search);
      // newParams.delete('document');
      // window.history.replaceState(null, '', `${window.location.pathname}${newParams}`);
    }
  }, []);

  useEffect(()=>{
    if(searchText.length < 1){
    handleAllSource();
    }
  },[searchText])

  const [askType, setAskType] = useState('document');
  const prevAskType = useRef(askType);

  const handleComfirmPopup = async (e) => {
    if (e.target.files.length > 0) {
      setSelectedFile(e);
    }
  };

  const handleThumbnailFileChange = (event) => {
    const file = event.target.files[0];
    if (file.type.startsWith('image/')) {
      const reader = new FileReader();
      reader.onload = (e) => {
        setPreviewThumbnailImage(e.target.result);
      };
      reader.readAsDataURL(file);
      setSelectedThumbnailFile(file);
    }
  };
  const sendMessage = async (question, id) => {
    setConversations('');
    if (!isLoading) {
      setIsLoading(true);

      const storedUserData = localStorage.getItem('User');
      const userData = storedUserData ? JSON.parse(storedUserData) : null;
      let result = newMessage.replace(groupValue, '');
      let payload = {
        question: result ? result.trim() : question,
        tapestry_id:selectedTapestry?.id,
        session_id: sessionId,
        GroupList: groupValue,
        name: userData.nick_name || userData.name,
        voice: userData.voice,
        parent: recentUpload[0]?.type == 'folder' ? recentUpload[0]?.name : '',
      };

      if (selectedDoc?.length > 0) {
        payload.documentName = selectedDoc;
      } else if (recentUpload?.length > 0) {
        const list = [];
        for (let item of recentUpload) {
          list.push(item.name);
        }
        payload.documentName = list;
      }
      if (id) {
        payload.id = id;
      }

      const token = userData?.authToken || '';
      let url = `${apiUrl}/admin/user_ask_question`;

      try {
        const response = await fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${token}`,
          },
          body: JSON.stringify(payload),
        });

        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let accumulatedAnswer = '';

        const conversationUpdate = {
          question: newMessage ? newMessage : question,
          answer: '',
        };
        if (id) {
          delete conversationUpdate.question;
        }

        setIsDeleteIconClicked(false);
        setConversation((prevConversation) => [
          ...prevConversation,
          conversationUpdate,
        ]);

        const decodeStream = async () => {
          while (true) {
            const { done, value } = await reader.read();

            if (done) {
              setIsLoading(false);
              setNewMessage('');
              setGeneratingId('');
              break;
            }

            const chunk = decoder.decode(value, { stream: true });
            accumulatedAnswer += chunk;

            setConversation((prevConversation) => {
              const lastConversation = [...prevConversation];
              lastConversation[lastConversation.length - 1].answer =
                accumulatedAnswer;
              return lastConversation;
            });
          }
        };

        decodeStream();
      } catch (error) {
        message.error(error || 'Error occurred');
        setIsLoading(false);
      }
    }
  };
  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({
      behavior: 'smooth',
      block: 'end',
    });
  };

  const sendMessageAuto = async () => {
    const storedUserData = localStorage.getItem('User');
    const userData = storedUserData ? JSON.parse(storedUserData) : null;
    const token = userData?.authToken || '';
    let payload = {
      question: '',
      tapestry_id:selectedTapestry?.id,
      groupId: groupName,
    };
    let url = `${apiUrl}/admin/user_ask_question`;
    try {
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify(payload),
      });
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let accumulatedAnswer = '';
      const conversationUpdate = {
        question: newMessage ? newMessage : '',
        answer: '',
      };
      setConversation((prevConversation) => [
        ...prevConversation,
        conversationUpdate,
      ]);
      const decodeStream = async () => {
        while (true) {
          const { done, value } = await reader.read();

          if (done) {
            setIsLoading(false);
            setNewMessage('');
            // setGroupValue('');
            break;
          }

          const chunk = decoder.decode(value, { stream: true });
          accumulatedAnswer += chunk;

          setConversations(accumulatedAnswer);
        }
      };

      decodeStream();
      // setGroupValue([]);
    } catch (error) {
      message.error(error);
    }
  };

  const removeDeleteButtons = (htmlContent: string) => {
    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = htmlContent;

    // Remove all delete buttons
    tempDiv.querySelectorAll(".delete-button").forEach((btn) => btn.remove());

    return tempDiv.innerHTML;
  };

  const handleNotePreview = (noteId)=>{
    console.log(noteId)
    navigate(`/notepad?note=${noteId}`);
  }

  useEffect(() => {
    if (!callMadeRef.current) {
      callMadeRef.current = true;
      sendMessageAuto();
    }
  }, []); // Add appropriate dependencies

  useEffect(() => {
    scrollToBottom();
  }, [conversation]);

  const handleCancel = (type) => {
    setIsModalOpen(false);
    if (type === 'ok') {
      return;
    }
    setSelected([]);
    setSelectedDoc([]);
  };

 const handleCopy = (content) => {
  navigator.clipboard
    .writeText(content)
    .then(() => {
      message.success('Content copied to clipboard!');
    })
    .catch((err) => {
      message.error('Failed to copy content');
    });
};


  const onChange = (e) => {
    setAskType(e.target.value);
  };
  const handleGroupChange = (e) => {
    setGroupName(e);
  };
  const groupOptions: OptionType[] = listData?.map((group: any) => ({
    value: group.id,
    label: group.name,
  }));

  useEffect(() => {
    if (selectedDoc?.length > 0) {
      setRecentUpload([]);
    }
  }, [selectedDoc]);

  function handleRemove(file, key) {
    setSelectedDoc(selectedDoc.filter((fileName) => fileName !== file));
    setSelected(
      selected.filter((index, id) => {
        if (key !== id) {
          return index;
        }
      })
    );
  }
  const showPopUp = () => {
    return (
      <Modal
        title={'Select Document..'}
        open={isModalOpen}
        centered
        style={{
          minWidth: '900px',
        }}
        onCancel={handleCancel}
        footer={[
          <button
            style={styles.cancelButton}
            key='cancel'
            onClick={() => handleCancel()}
          >
            Cancel
          </button>,
          <button
            style={styles.okButton}
            key='ok'
            onClick={() => handleCancel('ok')}
          >
            Ok
          </button>,
        ]}
      >
        <SourceDocuments
          selected={selected}
          setSelected={setSelected}
          selectedDoc={selectedDoc}
          setSelectedDoc={setSelectedDoc}
        />
      </Modal>
    );
  };
  const handleSelection = () => {
    setSelectedFile(null);
    selectedFile.target.value = null; // Clear the input
    setShowConfirmationPopup(false);
    setCaption('');
  };

  const handleClickOutside = (event) => {
    if (
      emojiPickerRef.current &&
      !emojiPickerRef.current.contains(event.target)
    ) {
      setShowEmojiPicker(false);
    }
  };

  useEffect(() => {
    document.addEventListener('mousedown', handleClickOutside);

    // Cleanup event listener on component unmount
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [showEmojiPicker]);

  const handleFileChange = async (yes) => {
    try {
      const formData = new FormData();
      let response;
      const files = Array.isArray(selectedFile)
        ? selectedFile
        : selectedFile instanceof FileList
          ? Array.from(selectedFile)
          : [selectedFile];
      setIsUploading(true);
      if (yes) {
        console.log(fileAllDetails, 'fileAllDetails');
        const createdDate = fileAllDetails?.relevantDate || moment();
        const expiryDate =
          fileAllDetails?.expiryDate || moment().add(1000, 'years');
        setYesUploadLoading(true);
        formData.append('tapestry_id',selectedTapestry?.id,);
        if (fileAllDetails?.group_Id && fileAllDetails?.group_Id?.length > 0) {
          fileAllDetails?.group_Id.forEach((groupId) => {
            formData.append('group_id', groupId);
          });
        }
        formData.append('file_title', fileAllDetails?.title || '');
        formData.append('author', fileAllDetails?.author);
        formData.append('about', fileAllDetails?.summary || '');
        if (selectedThumbnailFile || []) {
          formData.append('thumbnail', selectedThumbnailFile);
        }
        formData.append(
          'created_date',
          moment(createdDate).format('YYYY-MM-DD')
        );
        formData.append('expiry_date', moment(expiryDate).format('YYYY-MM-DD'));
        formData.append('caption', caption||'');
        formData.append('audioUrl', audioUrl|| '');
        formData.append('voice', voiceUrl || '');
        formData.append('voice_text', voiceNoteCaption||'')

        files?.forEach((ele) => {
          let data = generateDocxBlob?.[ele.name] || '';
          if (data instanceof Blob) {
            data = new File([data], ele.name, { type: 'image/png' });
          }
          formData.append('documents', ele as File);
          if (data) {
            formData.append('generatedDocImage', data);
          }
        });
        let response;
        if (fileAllDetails?.group_Id?.length > 0) {
          response = await AddGroupDocumentApi(formData);
        } else {
          response = await AddDocumentApi(formData);
        }
        if (response.code == 200) {
          setRecentUpload(files);
        }
      } else {
        setNoUploadLoading(true);
        formData.append('tapestry_id',selectedTapestry?.id);
        if (audioUrl) {
          formData.append('audioUrl', audioUrl);
        }
        formData.append('caption', caption);
        files?.forEach((ele) => {
          let data = generateDocxBlob?.[ele.name] || '';
          if (data instanceof Blob) {
            data = new File([data], ele.name, { type: 'image/png' });
          }
          formData.append('documents', ele as File);
          if (data) {
            formData.append('generatedDocImage', data);
          }
        });
        let response = await uploadDocumentsApi(formData);
        if (response.code == 200) {
          setRecentUpload(files);
        }
      }
    } catch (err) {
      console.log(err, 'hdue');
    } finally {
      setFileAllDetails({
        author: selectedTapestry?.tapestry_user_name,
        title: '',
        relevantDate: '',
        expiryDate: '',
        summary: '',
      });
      setSelected([]);
      setCaption('');
      setSelectedDoc([]);
      setAudioURL(null);
      setCaptureImg(null);
      setYesUploadLoading(false);
      setNoUploadLoading(false);
      setShowConfirmationPopup(false);
      setFileUploadPopup(false);
      setSelectedFile(null);
      setFileUploadPopup(false);
      setSelectedThumbnailFile(null);
      setIsUploading(false);
      setPreviewThumbnailImage(null);
    }
  };

  const handleInnerChange = (newOpen: boolean) => {
    setIsInnerOpen(newOpen);
  };

  const handlePictureInPicture = async () => {
    const note = await handleCreateNote(createNote, selectedTapestry?.id);
    if (note) {
      handlePipView([note], true);
    } else {
      console.error('Failed to create note. Cannot open Picture-in-Picture.');
    }
  };
  function removeTripleBackticks(text) {
    return text?.replace(/```/g, '').trim();
  }
  const content = (
    <div className='cursor-pointer p-1 '>
      <div
        className='flex gap-3 items-center px-1 py-[4px] rounded-lg hover:bg-slate-100'
        onClick={() => {
          setOpenAddSourceTable(true);
          setIsInnerOpen(false);
        }}
      >
        <PlusOutlined
          style={{ fontSize: '20px', color: selectedTapestry?.button_color }}
        />
        <span> Add source</span>
      </div>
      <div
        className='flex w-full gap-2 items-center px-1 py-[4px] rounded-lg  hover:bg-slate-100'
        onClick={() => {
          handlePictureInPicture(), setIsInnerOpen(false);
        }}
      >
        <span>
          <svg
            xmlns='http://www.w3.org/2000/svg'
            width='20'
            height='20'
            color={selectedTapestry?.button_color}
            viewBox='0 0 24 24'
            fill='none'
            stroke='currentColor'
            stroke-width='1.5'
            stroke-linecap='round'
            stroke-linejoin='round'
            class='lucide lucide-notebook-pen'
          >
            <path d='M13.4 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-7.4' />
            <path d='M2 6h4' />
            <path d='M2 10h4' />
            <path d='M2 14h4' />
            <path d='M2 18h4' />
            <path d='M21.378 5.626a1 1 0 1 0-3.004-3.004l-5.01 5.012a2 2 0 0 0-.506.854l-.837 2.87a.5.5 0 0 0 .62.62l2.87-.837a2 2 0 0 0 .854-.506z' />
          </svg>
        </span>
        <span> Create note</span>
      </div>
      <div
        className='flex w-full gap-2 items-center px-1 py-[4px] rounded-lg hover:bg-slate-100'
        onClick={() => {
          setShowConfirmationPopup(true);
          setIsInnerOpen(false);
        }}
      >
        <span>
          <IoCloudUploadOutline color={selectedTapestry?.button_color} size='20px' />
        </span>
        <span> Upload</span>
      </div>
      <div
        className='flex gap-3 items-center px-1 py-[4px] rounded-lg hover:bg-slate-100'
        onClick={() => {
          handleCreateSession();
          setIsInnerOpen(false);
        }}
      >
        <MessageOutlined
          style={{ fontSize: '19px', color: selectedTapestry?.button_color }}
        />
        <span> New chat</span>
      </div>
    </div>
  );

  const renderContent = (part, index) => {
    const linkPattern = /(<a\s+href="([^"]+\.(\w+))">([^<]+)<\/a>)/g;
    const urlPattern =
      /(https?:\/\/[^\s]+\.(?:png|jpg|jpeg|webp|gif|webm|svg))/g;
    const audioPattern = /(https?:\/\/[^\s]+\.(?:mp3))/g;

    const tempDiv = document.createElement('div');
    const documents = part?.document ? JSON.parse(part.document) : [];

    return (
      <>
        <div className='flex flex-col border-1 rounded-lg'>
          <article className="prose" key={index} style={styles.answerText}>
            {!previewItems.includes(part.id) ? (
              <Markdown
                remarkPlugins={[remarkGfm]}
                rehypePlugins={[rehypeRaw]}
                components={{
                  code({ node, inline, className, children, ...props }) {
                    const match = /language-(\w+)/.exec(className || '');
                    return !inline && match ? (
                      <SyntaxHighlighter
                        style={oneDark}
                        language={match[1]}
                        PreTag="div"
                        {...props}
                      >
                        {String(children).replace(/\n$/, '')}
                      </SyntaxHighlighter>
                    ) : (
                      <code className={className} {...props}>
                        {children}
                      </code>
                    );
                  },
                }}
              >
                {part?.answer}
              </Markdown>
            ) : (
              <Markdown>{part?.answer}</Markdown>
            )}
          </article>


          {part?.audio && (
            <>
              <div
                className='phttps://local-testing-tapestry-bucket.s3.amazonaws.com/0bc48760-0b00-11f0-a86c-c77c93081c81.jpg'
              >
                {audioToShow?.url === part?.audio && (
                  <audio
                    controls
                    autoPlay
                    key={audioToShow?.generatedUrl}
                    className='shadow-md rounded-full hidden'
                    ref={audioRef}
                  >
                    <source src={audioToShow?.generatedUrl} />
                    Your browser does not support the audio element.
                  </audio>
                )}
              </div>
            </>
          )}

          {documents.length > 0 && (
            <>
              <div className='h-[1px] mx-4 mt-2 bg-gray-200'></div>
              <div className='ask-document-page'>
                <div className='mx-4 px-2 grid-tapestry-view-container '>
                  <div className='container-grid tapestry-grid'>
                    {documents?.map((doc, docIndex) => {
                      if(doc?.file_id){
                        const isaudio =
                          doc?.file_type.match(/(mp3)/) ||
                          doc?.file_type.match(/(opus)/);
                      }

                      return (
                        <>
                          {doc?.file_id ? (
                            <div className='card p-2 min-w-[180px]'>
                              <div
                                className={
                                  doc.file_type === 'jpg' ||
                                  doc.file_type === 'svg' ||
                                  doc.file_type === 'jpeg' ||
                                  doc.file_type === 'mov' ||
                                  doc.file_type === 'mp4' ||
                                  doc.file_type === 'mkv' ||
                                  doc.file_type === 'webm' ||
                                  doc.file_type === 'png' ||
                                  doc.file_type === 'webp'
                                    ? 'doc-container rounded relative group w-full bg-[#d9d9d9] flex items-center cursor-pointer justify-center'
                                    : 'doc-container  rounded relative group w-full bg-white flex items-center cursor-pointer'
                                }
                                onClick={() => {
                                  handleNavigation(doc);
                                }}
                              >
                                {findIcon(
                                  doc?.file_type,
                                  doc?.file_id,
                                  doc?.thumbnail
                                )}
                                <div className='doc-detail p-3 absolute bottom-0 left-0 text-white w-full group-hover:bg-gradient-to-b from-[#00000000] to-[#1c1c1caa] rounded-b-lg'>
                                  <p className='w-full truncate opacity-0 group-hover:opacity-100 text-[14px]'>
                                    {doc?.name}
                                  </p>
                                </div>
                              </div>
                              {/* <div>
                                <h6 className='truncate line-clamp-2 text-wrap font-semibold text-[14px] mt-[6px]'>
                                  {doc.about ? doc.about : doc.added_by}
                                </h6>
                                <p className='truncate line-clamp-2 text-wrap text-[14px] mt-[2px]'>
                                  {doc.caption}
                                </p>
                              </div> */}
                            </div>
                          ):(
                            <div className='card p-2 min-w-[180px]'>
                              <div className='p-[1.5px] rounded-xl max-w-[200px] max-h-[180px] cursor-pointer box-border'
                                style={{ border: `2px solid ${ doc?.color ? doc?.color : '#E5E7EB' }` }}
                                onClick={()=> handleNotePreview(doc?.id)}
                              >
                                <div
                                  key={doc?.id}
                                  contentEditable="false"
                                  className={` relative h-full flex flex-col justify-between group border-gray-200 p-3 rounded-lg shadow-sm transition-colors 
                                    [&_ul]:list-disc [&_ul]:pl-5 [&_ol]:list-decimal [&_ol]:pl-5 `}
                                    style={{
                                      backgroundColor: doc?.color ? hexToLightRgba(`${doc?.color}`, 0.4) : "white",
                                      padding: '10px'
                                  }}
                                >
                                  <div>
                                    <div className='flex gap-1 items-center'>
                                      <img src={stickyNote} className='h-[22px] mx-[5px]'></img>
                                      <h1 className=' truncate w-60  '>
                                        {(doc?.type == 1 || doc?.type == 3) ? doc?.title : doc?.title?.replace(/_\d+\.ipynb$/, '')}
                                      </h1>
                                    </div>
                                    {(doc?.type == 1||doc?.type == 3) &&
                                      <div className='mt-3 border' ></div>
                                    }
                                    {doc?.content !== 'undefined' && (
                                      <p className={` pt-3 text-xs text-justify text-gray-500  line-clamp-4 max-h-[80px] `}>
                                        {parse(removeDeleteButtons(doc?.content))}
                                      </p>
                                    )}
                                  </div> 
                                    <div className='pt-4 flex justify-end items-center text-xs'>
                                      <span> {moment(doc?.createdAt)?.format('DD MMMM YYYY')}</span>
                                    </div>
                                </div>
                              </div>
                            </div>
                            
                          )}
                        </>
                      );
                    })}
                  </div>
                </div>
              </div>
            </>
          )}

          <div className='text-[12px] text-gray-600 text-right pb-[1px] pr-1 '>
            <span className=''>{moment(part?.createdAt).format('HH:mm')}</span>
          </div>
        </div>
      </>
    );
  };

  const handleRegenerateResponse = (response) => {
    setGeneratingId(response.id);
    sendMessage(response.question, response.id);
  };

  const stopvoice = () => {
    setAudioToShow({
      url: '',
      generatedUrl: '',
    });
  };

  const renderMessage = (msg, index) => {
    if (msg.question || msg.answer) {
    return (
          <div key={index} className='mt-4 relative'>
            {msg.question && (
              <div className='flex justify-end'>
                <div style={styles.message} className='min-w-40 max-w-[80%]'>
                  <div style={styles.messageContent} className=' rounded-lg'>
                    <p className='px-[10px] py-[8px] rounded-[20px] m-0 text-base'>
                      {msg.question}
                    </p>
                  </div>
                </div>
              </div>
            )}
            {msg.id != generatingId && (
              <div
                className='mt-2 flex flex-col'
                style={{ ...styles.messageParent }}
              >
                <div
                  style={styles.messageContent}
                  className='bg-white w-full mb-2'
                >
                  {renderContent(msg)}
                </div>
                {!isLoading && (
                  <div className='flex text-[#96999f]'>
                    <CopyOutlined
                      className='text-xl pl-3 mb-5'
                      onClick={() => handleCopy(msg.answer)}
                    />
                    {temporaryFeedback[msg.id] == 'like' ? (
                      <LikeFilled
                        className='text-xl pl-3 mb-5'
                        onClick={() => handleSubmitResponse('like', '', msg.id)}
                      />
                    ) : (
                      <LikeOutlined
                        className='text-xl pl-3 mb-5'
                        onClick={() =>
                          handleSubmitResponse('like', 'Good response', msg.id)
                        }
                      />
                    )}
                    {temporaryFeedback[msg.id] == 'dislike' ? (
                      <DislikeFilled
                        className='text-xl pl-3 mb-5 pt-1'
                        onClick={() =>
                          handleSubmitResponse('dislike', '', msg.id)
                        }
                      />
                    ) : (
                      <DislikeOutlined
                        className='text-xl pl-3 mb-5 pt-1'
                        onClick={() =>
                          setfeedbackModal({
                            open: true,
                            id: msg.id,
                          })
                        }
                      />
                    )}
                    {isPlaying && audioToShow?.url == msg?.audio ? (
                      <SoundFilled
                        className='text-xl pl-3 mb-5'
                        onClick={() => stopvoice()}
                      />
                    ) : (
                      <SoundOutlined
                        className='text-xl pl-3 mb-5'
                        onClick={() =>
                          handleGeneateSignedUrl(msg?.audio, 'audio')
                        }
                      />
                    )}
                  
                    {(conversation.length - 1 == index ||
                      (conversation.length - 2 == index &&
                        conversation[conversation.length - 1].question ==
                          '')) && (
                      <RedoOutlined
                        className='text-xl pl-3 mb-5'
                        onClick={() => handleRegenerateResponse(msg)}
                      />
                    )}
                    {previewItems.includes(msg.id)? <EyeInvisibleOutlined onClick={()=>handlePreview(msg.id)}
                        className='text-xl pl-3 mb-5 cursor-pointer'
                        />:
                      <EyeOutlined onClick={()=>handlePreview(msg.id)}
                        className='text-xl pl-3 mb-5 cursor-pointer'
                        />
                    }
                  </div>
                )}
              </div>
            )}
          </div>
    );
  }
  };

  // Handle selecting a group from the popover
  const handleGroupSelect = (group) => {
    setNewMessage('');
    setGroupName(group.value);
    if (groupValue) {
      if (!groupValue.includes(group.label)) {
        setGroupValue([...groupValue, group.label]);
      }
    } else {
      setGroupValue([...groupValue, group.label]);
    }
    setIsPopoverVisible(false);
  };

  const preventDefault = (e, group) => {
    e.preventDefault();
    console.log(group, groupValue, 'miejd');
    setGroupValue(groupValue.filter((ele) => ele !== group));
  };

  const renderSelectedGroup = () => {
    if (groupValue) {
      return (
        // <div style={styles.selectedGroup} onClick={() => setGroupValue('')}>
        //   {groupValue}{' '}
        //   <span className='text-red-800  rounded-md p-1  bg-red-300 '>
        //     <CloseOutlined />
        //   </span>
        // </div>
        <div className='tag-div absolute bottom-[48px] left-[78px] flex flex-wrap'>
          {groupValue.map((group, key) => (
            <div key={key}>
              <Tag
                closeIcon
                onClose={(e) => preventDefault(e, group)}
                className='px-1 py-[5px] text-[14px]'
              >
                {group}
              </Tag>
            </div>
          ))}
        </div>
      );
    }
    return null;
  };

  const handleTextChange = (e) => {
    const value = e.target.value;
    setNewMessage(value);
    setMessages(value);

    // Show the popover if '@' is typed
    if (value.endsWith('@') && role != 4) {
      setIsPopoverVisible(true);
    } else {
      setIsPopoverVisible(false);
    }
  };

const handleFeedback = (selected) => {
  setFeedback((prevFeedback) => {
    if (prevFeedback.includes(selected)) {
      return prevFeedback.filter((item) => item !== selected);
    } else {
      return [...prevFeedback, selected];
    }
  });
};

  const handleCreateSession = () => {
    if (sessionList?.length > 0 && sessionList[0]?.name !== '') {
      createSession();
    }
  };
  
  // const handleSearch=(e)=>{
  //   setSearchText(e.target.value)
  // }

  const columns = [
    {
      dataIndex: 'file_title',
      title: 'File Title',
      display: 'flex',
      alignItems: 'center',
      onHeaderCell: () => ({
        style: { minWidth: 250, maxWidth: 300 },
      }),
      onCell: () => ({
        style: { minWidth: 250, maxWidth: 300 },
      }),
    },
    {
      dataIndex: 'author',
      title: 'Author',
      display: 'flex',
      alignItems: 'center',
      // width: 250,
    },
    {
      dataIndex: 'parent',
      title: 'Collection',
      display: 'flex',
      alignItems: 'center',
      // width: 250,
    },
    {
      dataIndex: 'file_id',
      title: 'View',
      width: 100,
      display: 'flex',
      alignItems: 'center',
      render: (text: string, item) => (
        <IoEyeOutline
          size={20}
          className='cursor-pointer'
          style={{ color: selectedTapestry?.button_color }}
          onClick={() => {
            window.open(item.file_id, '_blank');
          }}
        />
      ),
    },
  ];

  // const ListData = allSources.map((item)=>{
  //   return { file_title: item.file_title, }
  // }) ;

  const rowSelection = {
    onChange: (selectedRowKeys, selectedRows) => {
      console.log(
        `selectedRowKeys: ${selectedRowKeys}`,
        'selectedRows: ',
        selectedRows
      );
      if (selectedRows.length > 0) {
        const fileId = [];
        const fileName = [];
        for (const item of selectedRows) {
          fileId.push(item.file_id);
          fileName.push(item.file_title);
        }
        setSelectedFileName(fileName);
        setSelectedFileId(fileId);
      } else {
        setSelectedFileName([]);
        setSelectedFileId([]);
      }
    },
  };

  return (
    <>
      {isUploading && <Loading />}
      {showComfirmationPopup ? (
        <FileComfirmPopup
          yesUploadLoading={yesUploadLoading}
          noUploadLoading={noUploadLoading}
          toggle={showComfirmationPopup}
          setShowConfirmationPopup={setShowConfirmationPopup}
          message={'Are you sure you want to delete the record ?'}
          onYes={handleFileChange}
          onNo={handleFileChange}
          onCancel={handleSelection}
          selectedFile={selectedFile}
          caption={caption}
          setCaptureImg={setCaptureImg}
          setSelectedFile={setSelectedFile}
          setCaption={setCaption}
          setAudioUrl={setAudioUrl}
          setVoiceUrl={setVoiceUrl}
          voiceNoteCaption={voiceNoteCaption}
          setVoiceNoteCaption={setVoiceNoteCaption}
          fileAllDetails={fileAllDetails}
          setFileAllDetails={setFileAllDetails}
          handleThumbnailFileChange={handleThumbnailFileChange}
          previewThumbnailImage={previewThumbnailImage}
          setPreviewThumbnailImage={setPreviewThumbnailImage}
          component={'askDocument'}
          generateDocxBlob={generateDocxBlob}
          setGenerateDocxBlob={setGenerateDocxBlob}
        />
      ) : openAddSourceTable ? (
        <div className='p-2 w-full flex flex-col '>

          <div className='py-2 gap-2 flex justify-between'>
              <SearchBar
                value={searchText}
                onChange={(e) => setSearchText(e.target.value)}
                onSearch={handleAllSource}
                className='max-w-[400px]'
              />
            <div className='flex'>
              <CustomModalButton
              key='cancel'
              text='Cancel'
              bgColor={'white'}
              borderColor={selectedTapestry?.button_color }
              textColor={selectedTapestry?.button_color}
              className="mr-2"
              disabled={false}
              onClick={() => {
                setSelectedFileName([]),
                  setSelectedFileId([]),
                  setOpenAddSourceTable(false);
              }}
            />
            <CustomModalButton
              key='submit'
              text='Submit'
              bgColor={selectedTapestry?.button_color}
              borderColor={selectedTapestry?.button_color}
              textColor={'white'}
              disabled={false}
              onClick={() => {
                selectedFileId.length >= 0 &&
                  setRecentUpload(() =>
                    allSources.filter((item) =>
                      selectedFileId.includes(item?.file_id)
                    )
                  ),
                  setOpenAddSourceTable(false);
              }}
            /></div>
          </div>
          <div className='overflow-x-auto flex-1'>
            <Table
              className='overflow-x-auto'
              dataSource={allSources}
              pagination={false}
              columns={columns}
              rowKey='file_id'
              //  loading={loading}
              rowSelection={rowSelection}
              // pagination={{
              //   total: totalRecords,
              //   current: pagination.currentPage,
              //   pageSize: pagination.pageSize,
              //   onChange:handlePageChange,
              // }}
              rowClassName={() => 'custom-row-class'}
            />
          </div>
        </div>
      ) : (
        <div
          style={styles.chatWindow}
          className=' transition-all duration-300 border-gray-200 rounded-lg shadow-[1px_1px_5px_rgb(137,137,137)]'
        >
          <h2
            style={styles.header}
            className='flex items-center w-full justify-between'
          >
            <div className='flex items-center my-2'>
              <span
                className='text-[14px] ml-3 pb-1 cursor-pointer'
                onClick={() => setSelectedTab('chat')}
                style={{
                  color: selectedTab == 'chat' ? selectedTapestry?.button_color : '',
                  borderBottom:
                    selectedTab == 'chat'
                      ? `2px solid ${selectedTapestry?.button_color}`
                      : '',
                }}
              >
                Chat
              </span>
              <span
                className='text-[14px] ml-8 pb-1 cursor-pointer'
                onClick={() => setSelectedTab('session')}
                style={{
                  color: selectedTab == 'session' ? selectedTapestry?.button_color : '',
                  borderBottom:
                    selectedTab == 'session'
                      ? `2px solid ${selectedTapestry?.button_color}`
                      : '',
                }}
              >
                History
              </span>
            </div>
            
          </h2>
          {selectedTab == 'chat' ? (
            <>
              <div className='chatWrapper' style={styles.messageContainer}>
                <>
                  {conversations ? (
                    <>
                      <CopyOutlined
                        className='absolute right-5 top-2 text-gray-500 cursor-pointer'
                        onClick={() => handleCopy(msg.answer)}
                      />
                      <div
                        style={styles.messageContent}
                        className='text-gray-400 bg-white p-3 border rounded-md'
                      >
                        {conversations}
                      </div>
                    </>
                  ) : (
                    conversation?.map((msg, index) => renderMessage(msg, index))
                  )}
                  <div
                    ref={messagesEndRef}
                    style={{ height: '1px', visibility: 'hidden' }}
                  />
                </>
              </div>

                <div className=' flex gap- items-center px-2 pb-2'>
                  <Modal
                    title='Feedback'
                    visible={feedbackModal.open}
                    onCancel={() => {
                      setfeedbackModal({
                        open: false,
                        id: null,
                      }),
                        setResponse(''),
                        setFeedback([])
                    }
                    }
                    className='reset-header mx-auto'
                    footer={[
                      <div className='flex justify-end'>
                        <CustomModalButton
                          key='cancel'
                          text='Cancel'
                          bgColor={'white'}
                          borderColor={selectedTapestry?.button_color}
                          textColor={selectedTapestry?.button_color}
                          className="mr-2"
                          disabled={false}
                          onClick={() => {
                            setfeedbackModal({
                              open: false,
                              id: null,
                            }),
                              setResponse(''),
                              setFeedback([]);
                          }}
                        />
                        <CustomModalButton
                          key='submit'
                          text='Submit'
                          bgColor={selectedTapestry?.button_color}
                          borderColor={selectedTapestry?.button_color}
                          textColor={'white'}
                          disabled={!response && feedback.length < 1}
                          onClick={() =>
                            !(!response && feedback.length < 1) &&
                            handleSubmitResponse(
                              'dislike',
                              `${feedback} ${response}`,
                              feedbackModal.id
                            )
                          }
                        />
                      </div>
                    ]}
                  >
                    <div className='flex flex-wrap'>
                      {' '}
                      {options.map((item, index) => {
                        const isSelected = feedback.includes(item);
                        return (
                          <div
                            className={`w-auto cursor-pointer text-[15px] mb-2 mr-2 p-2 border font-semibold rounded-md ${isSelected ? 'border-blue-400 bg-blue-200 text-blue-600' : 'border-gray-400'}`}
                            key={index}
                            onClick={() => {
                              handleFeedback(item);
                            }}
                          >
                            {item}
                          </div>
                        );
                      })}
                    </div>
                    <TextArea
                      autoSize={{
                        minRows: 3,
                        maxRows: 5,
                      }}
                      className='border border-gray-400 text-[14px] mt-5'
                      placeholder='Type your feedback'
                      value={response || ''}
                      onChange={(e) => setResponse(e.target.value)}
                    ></TextArea>
                  </Modal>

                  {!isRecording && (
                    <>
                      <p
                        className='mr-1 emoji-wrap-icon cursor-pointer rounded-full w-[31px] h-[27px] flex justify-center items-center hover:bg-gray-300'
                        onClick={() => setShowEmojiPicker(!showEmojiPicker)}
                      >
                        <BsEmojiSmile size={20} />
                      </p>
                      {showEmojiPicker && (
                        <div ref={emojiPickerRef}>
                          <EmojiPicker
                            className='emoji_container'
                            height={341}
                            width={292}
                            onEmojiClick={(emojiObject) =>
                              setNewMessage(
                                (prevMsg) => prevMsg + emojiObject.emoji
                              )
                            }
                          />
                        </div>
                      )}

                      {/* <span
          className='mr-2 emoji-wrap-icon cursor-pointer text-lg w-[30px] h-[27px] flex justify-center items-center hover:bg-gray-300 rounded-[50%]'
          onClick={() => {
            setIsModalOpen(true);
            setRecentUpload(null);
          }}
        >

          <PlusOutlined />
        </span> */}
                      <Popover
                        open={isInnerOpen}
                        onOpenChange={handleInnerChange}
                        content={content}
                        trigger='click'
                      >
                        <span
                          onClick={(e) => e.stopPropagation()}
                          // onMouseEnter={() => setIsInnerOpen(true)}
                          className=' mr-1 paper-clip cursor-pointer !text-lg rounded-full w-[30px] h-[27px] flex justify-center items-center hover:bg-gray-300'
                        >
                          <PlusOutlined
                            className={`plus-icon ${isInnerOpen ? 'open' : ''}`}
                          />
                        </span>
                      </Popover>
                    </>
                  )}

                  {isRecording ? (
                    <>
                      <button title='Voice note'>
                        <FaMicrophone
                          style={{
                            color: 'red',

                            marginLeft: '8px',
                            fontSize: '24px',
                            transition: 'box-shadow 0.3s ease-in-out',
                            boxShadow: '0px 0px 5px 1px rgba(255, 0, 0, 0.2)',
                            animation: 'pulse 0.6s infinite alternate',
                            background: 'transparent', // Ensures no white box
                            padding: 2, // Removes any extra padding
                            borderRadius: '50%', // Makes sure it's round
                          }}
                          size={20}
                        />
                      </button>
                    </>
                  ) : (
                    <>
                      <Popover
                        placement='top'
                        content={
                          <div>
                            {groupOptions == 0 ? (
                              <p>No groups</p>
                            ) : (
                              <>
                                {groupOptions?.map((group) => (
                                  <div
                                    className='hover:bg-grey-500'
                                    key={group.value}
                                    onClick={() => handleGroupSelect(group)}
                                    style={{
                                      padding: '4px 8px',
                                      cursor: 'pointer',
                                      backgroundColor: '#F1F5F9',
                                      marginBottom: '4px',
                                    }}
                                  >
                                    {group.label}
                                  </div>
                                ))}
                              </>
                            )}
                          </div>
                        }
                        trigger='click'
                        visible={isPopoverVisible}
                        onVisibleChange={(visible) =>
                          setIsPopoverVisible(visible)
                        }
                      ></Popover>
                      {renderSelectedGroup()}
                    </>
                  )}
                  <TextArea
                    type='text'
                    autoSize={{
                      minRows: 1,
                      maxRows: 4,
                    }}
                    className='focus:shadow-none outline-none border-1 focus:border-[#a6a8a8] hover:border-[#a6a8a8]'
                    placeholder='Type something to ask...'
                    value={newMessage}
                    onChange={handleTextChange}
                    style={styles.input}
                    onKeyDown={(e) => {
                      if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        sendMessage();
                      }
                    }}
                  />
                  {recentUpload[0]?.type !== 'note' && (
                    <div className='absolute flex bottom-[55px] left-[70px]'>
                      {recentUpload.map((file, key) => (
                        <div
                          key={key}
                          className='border-2 ml-[2px]  flex justify-between max-w-[250px] w-full bg-white px-3 py-1 shadow-lg pt-1'
                        >
                          {file?.type !== 'note' && (
                            <>
                              <span className='max-w-[250px] truncate '>
                                {file.name}
                              </span>
                              <CloseOutlined
                                size={18}
                                className=' cursor-pointer'
                                onClick={() =>
                                  setRecentUpload(
                                    recentUpload.filter(
                                      (fileName) => fileName.name !== file.name
                                    )
                                  )
                                }
                              />
                            </>
                          )}
                        </div>
                      ))}
                    </div>
                  )}
                  {selectedDoc && (
                    <div className='absolute flex top-[-35px] left-[70px]'>
                      {selectedDoc?.map((file, key) => (
                        <div
                          key={key}
                          className='border-2 ml-[2px]  flex justify-between max-w-[250px] w-full bg-white px-3 py-1 shadow-lg pt-1'
                        >
                          <span className='max-w-[250px]  truncate '>{file}</span>
                          <CloseOutlined
                            size={18}
                            className=' cursor-pointer'
                            onClick={() => handleRemove(file, key)}
                          />
                        </div>
                      ))}
                    </div>
                  )}

                  {!newMessage ? (
                    !isRecording ? (
                      <Button
                        className=' audio-oultine-wrap'
                        icon={<FaMicrophone size={18} />}
                        setOpenAddSourceTable
                        onClick={() => setIsRecording(true)}
                        disabled={isLoading}
                        style={styles.buttonAudio}
                      />
                    ) : (
                      <button
                        onClick={() => stopRecording()}
                        className={'cursor-pointer'}
                      >
                        <IoSend size={20} />
                      </button>
                    )
                  ) : (
                    <>
                      {isLoading ? (
                        <button
                          onClick={sendMessage}
                          className='cursor-not-allowed'
                          style={styles.button}
                        >
                          Generating...
                        </button>
                      ) : (
                        <button
                          onClick={() =>
                            isRecording ? stopRecording() : sendMessage()
                          }
                          className={'cursor-pointer'}
                          style={styles.buttonsend}
                        >
                          <IoSend size={20} />
                        </button>
                      )}
                    </>
                  )}
                </div>
            </>
          ) : (
            <div
              className=' sessionTable mt-[10px] py-4  overflow-auto w-full bg-white '
              style={{
                height: `calc(100vh - 90px)`,
                borderRadius: '10px',
                boxShadow: ' 1px 1px 5px rgb(137, 137, 137)',
                backgroundColor: 'rgb(248, 248, 248)',
              }}
            >
              <div className=' '>
                <div className='sessionTable__heading py-4 px-6 flex justify-between text-xs text-gray-500  '>
                  <span className='md:max-w-[400px]  max-w-[500px]  '>
                    MESSAGE CONTENT
                  </span>
                  <div className='flex justify-between gap-20 '>
                    <span className=' min-w-[140px] text-center '>
                      SESSION DATE
                    </span>
                    <div className='min-w-[80px]  flex justify-center  '>
                      <span>ACTIONS</span>
                    </div>
                  </div>
                </div>

                {sessionList?.map((item, index) => (
                  <div
                    key={index}
                    className={`sessionTable__item py-4 px-6 flex justify-between  gap-10 cursor-pointer text-sm  active:bg-gray-200  transition-colors ${item?.id == sessionId ? 'bg-gray-300 hover:bg-gray-300' : 'hover:bg-gray-200 '}`}
                    onClick={() => {
                      setSessionId(item.id), setSelectedTab('chat');
                    }}
                  >
                    <div className='w-[300px]'>
                      <span className=' text-sm line-clamp-1  '>
                        {' '}
                        {item.name ? item.name : 'New chat'}
                      </span>
                    </div>
                    <div className='flex justify-between gap-20 '>
                      <span>
                        {moment(item.createdAt).format('D-MM-YYYY, h:mm a')}
                      </span>
                      <div className=' min-w-[80px]  flex justify-center'>
                        <button
                          type='button'
                          onClick={(e) => {
                            e.stopPropagation();
                            clearChatHistory(item.id);
                          }}
                        >
                          <MdDelete size={20} />
                        </button>
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}
        </div>
      )}
    </>
  
  );
})
export default AskDocument;

const styles = {
  chatWindow: {
    display: 'flex',
    flexDirection: 'column',
    height: 'calc(100vh - 20px)',
    width: '100%',
    margin: '10px 8px 0px 8px',
    fontFamily: 'Arial, sans-serif',
    position: 'relative',
    fontSize: '15px',
  },
  recordingIcon: {
    // position: 'fixed',
    bottom: '20px',
    right: '20px',
    width: '50px',
    height: '50px',
  },
  header: {
    backgroundColor: 'white',
    padding: '10px',
    // fontWeight: 600,
    fontSize: '16px',
    lineHeight: 'normal',
    top: '0',
    width: '100%',
    left: 0,
    zIndex: 980,
    display: 'flex',
    alignItems: 'center',
    boxShadow: '1px 2px 3px lightgray',
    borderRadius: '6px',
  },
  audio: {
    padding: '3px',
  },
  link: {
    color: 'blue',
    borderBottom: '1px solid blue',
    cursor: 'pointer',
    textDecoration: 'none',
  },

  buttonAudio: {
    padding: '5px 10px',
    border: 'none',
    borderRadius: '12px', // Rounded button
    cursor: 'pointer',
    color: '#54656F',
    background: 'none',
  },

  messageContainer: {
    padding: '9px 10px 0px',
    display: 'flex',
    flexDirection: 'column',
    overflow: 'auto',
    marginBottom: '10px',
    height: 'calc(100vh - 120px)',
    backgroundSize: 'contain',
    backgroundPosition: 'center',
    backgroundImage: `url(${backgroundImage})`,
  },
  messageParent: {
    width: 'fit-content',
    display: 'flex',
    alignItems: 'start',
  },
  message: {
    marginBottom: '10px',
    borderRadius: '8px',
    background: 'white',
    overflow: 'hidden',
  },
  messageContent: {
    wordBreak: 'break-word',
    borderRadius: '12px',
    maxWidth: '50vw'
  },
  messageText: {
    padding: '10px 20px',
    borderRadius: '20px',
    margin: 0,
  },
  answer: {
    display: 'flex',
    flexDirection: 'column',
    marginLeft: '42px',
    marginTop: '10px',
    position: 'relative',
  },
  sent: {
    alignSelf: 'flex-end',
  },
  received: {
    alignSelf: 'flex-start',
  },
  selectedGroup: {
    display: 'inline-block',
    backgroundColor: 'Lightgray',
    color: '#333',
    padding: '8px 8px',
    borderRadius: '4px',
    margin: 'px',
    fontSize: '12px',
    fontWeight: 'bold',
    cursor: 'pointer',
  },
  answerText: {
    padding: '10px 20px',
    borderRadius: '20px',
    // backgroundColor: '#E0E0E0',
    whiteSpace: 'normal', // This ensures that the text wraps within the container
    wordBreak: 'break-word',
    fontFamily: 'Arial, sans-serif',
  },
  answerImage: {
    maxWidth: '100%',
    borderRadius: '8px',
    maxHeight: '500px',
    objectFit: 'cover',
    minHeight: '200px',
  },
  messageInput: {
    position: 'absolute', // Changed to position fixed
    bottom: '0',
    left: '0',
    width: '100%',
    display: 'flex',
    alignItems: 'center',
    padding: '11px 6px',
  },
  input: {
    width: '100%',
    padding: '8px',
    borderRadius: '16px',
    fontSize: '14px',
    marginRight: '10px',
    marginLeft: '6px',
    outline: 'none',
  },
  button: {
    padding: '8px 12px',
    border: 'none',
    fontSize: '14px',
    borderRadius: '12px', // Rounded button
    background: 'linear-gradient(to right, #3819CF 0%, #684DEE 100%)',
    color: 'white',
    transition: 'background-color 0.3s ease',
  },
  buttonsend: {
    padding: '8px 12px',
    border: 'none',
    fontSize: '14px',
    cursor: 'pointer',
    color: '#54656F',
    background: 'none',
  },
  cancelButton: {
    width: '100px',
    color: '#684DEE',
    background: 'white',
    border: '1px solid #684DEE',
    paddingTop: '3px',
    fontSize: '14px',
    paddingBottom: '3px',
    borderRadius: '14px',
    cursor: 'pointer',
    marginRight: '10px',
  },
  okButton: {
    width: '100px',
    color: 'white',
    background: 'linear-gradient(to right, #684DEE 0%, #684DEE 100%)',
    border: '1px solid #684DEE',
    paddingTop: '3px',
    fontSize: '14px',
    paddingBottom: '3px',
    borderRadius: '14px',
    cursor: 'pointer',
  },
  buttonHover: {
    background: 'linear-gradient(to right, #684DEE 0%, #684DEE 100%)',
  },
  senderProfile: {
    fontWeight: 'bold',
  },
};